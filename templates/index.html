<!DOCTYPE html>
<html>
<head>
    <title>Floor Plan 3D - Complete Solution</title>
    <style>
        body { margin: 0; overflow: hidden; font-family: Arial; }
        #container { position: relative; width: 100vw; height: 100vh; }
        #firstPersonView { width: 100%; height: 100%; }
        #topDownView {
            position: absolute;
            bottom: 20px;
            right: 20px;
            width: 300px;
            height: 300px;
            border: 2px solid white;
            z-index: 100;
        }
        #info {
            position: absolute;
            top: 10px;
            left: 10px;
            color: white;
            background: rgba(0,0,0,0.5);
            padding: 10px;
            border-radius: 5px;
        }
        #loading {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            color: white;
            background: rgba(0,0,0,0.8);
            padding: 20px;
            border-radius: 10px;
            text-align: center;
            z-index: 200;
        }
        #error {
            color: #ff6b6b;
            margin-top: 10px;
            font-size: 14px;
        }
    </style>
</head>
<body>
    <div id="container">
        <div id="firstPersonView"></div>
        <div id="topDownView"></div>
        <div id="info">WASD to move | Mouse to look | Click to lock controls</div>
        <div id="loading">
            <h3>Loading 3D Model</h3>
            <progress value="0" max="100"></progress>
            <div id="status">Initializing...</div>
            <div id="error"></div>
        </div>
    </div>

    <!-- Three.js from CDN with fallback -->
    <script src="https://cdn.jsdelivr.net/npm/three@0.132.2/build/three.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/three@0.132.2/examples/js/controls/PointerLockControls.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/three@0.132.2/examples/js/controls/OrbitControls.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/three@0.132.2/examples/js/utils/BufferGeometryUtils.js"></script>

    <script>
        // ========================
        // INITIALIZATION
        // ========================
        let scene, fpCamera, topDownCamera, fpControls, orbitControls;
        let firstPersonRenderer, topDownRenderer;
        const moveSpeed = 0.2;
        const keys = {};

        // UI Elements
        const statusElement = document.getElementById('status');
        const errorElement = document.getElementById('error');
        const progressBar = document.querySelector('progress');

        function updateStatus(text, progress) {
            statusElement.textContent = text;
            progressBar.value = progress;
        }

        function showError(message) {
            errorElement.innerHTML = `Error: ${message}<br>Check browser console (F12) for details`;
            console.error(message);
        }

        // ========================
        // SCENE SETUP
        // ========================
        function initScene() {
            try {
                // 1. Verify Three.js loaded
                if (!THREE) throw new Error("Three.js failed to load");
                
                updateStatus("Creating scene...", 10);
                
                // 2. Create scene and renderers
                scene = new THREE.Scene();
                scene.background = new THREE.Color(0x87CEEB);
                
                firstPersonRenderer = new THREE.WebGLRenderer({ antialias: true });
                firstPersonRenderer.setSize(window.innerWidth, window.innerHeight);
                firstPersonRenderer.setPixelRatio(Math.min(window.devicePixelRatio, 1.5));
                document.getElementById('firstPersonView').appendChild(firstPersonRenderer.domElement);
                
                topDownRenderer = new THREE.WebGLRenderer({ antialias: true });
                topDownRenderer.setSize(300, 300);
                topDownRenderer.setPixelRatio(1);
                document.getElementById('topDownView').appendChild(topDownRenderer.domElement);
                
                // 3. Create cameras
                fpCamera = new THREE.PerspectiveCamera(75, window.innerWidth/window.innerHeight, 0.1, 1000);
                fpCamera.position.set(0, 1.6, 10); // Start position
                
                topDownCamera = new THREE.OrthographicCamera(-50, 50, 50, -50, 1, 1000);
                topDownCamera.position.set(0, 50, 0);
                topDownCamera.lookAt(0, 0, 0);
                
                // 4. Add lighting
                const ambientLight = new THREE.AmbientLight(0xffffff, 0.5);
                scene.add(ambientLight);
                const directionalLight = new THREE.DirectionalLight(0xffffff, 0.8);
                directionalLight.position.set(10, 20, 10);
                scene.add(directionalLight);
                
                // 5. Add floor
                const floorGeometry = new THREE.PlaneGeometry(100, 100);
                const floorMaterial = new THREE.MeshStandardMaterial({ 
                    color: 0xcccccc, 
                    roughness: 0.8 
                });
                const floor = new THREE.Mesh(floorGeometry, floorMaterial);
                floor.rotation.x = -Math.PI / 2;
                scene.add(floor);
                
                updateStatus("Scene ready", 20);
                return true;
                
            } catch (err) {
                showError(`Scene initialization failed: ${err.message}`);
                return false;
            }
        }

        // ========================
        // MODEL LOADING
        // ========================
        async function loadModel() {
            if (!initScene()) return;
            
            try {
                updateStatus("Loading floor plan...", 30);
                
                // 1. Load image
                const img = await loadImage('floorplan.png');
                updateStatus("Processing image...", 50);
                
                // 2. Process image
                const { walls, doors, windows, width, height } = await processImage(img);
                
                console.log('Image dimensions:', width, height);
                console.log('Walls count:', walls.length);
                console.log('Doors count:', doors.length);
                console.log('Windows count:', windows.length);
                
                // 3. Create walls
                updateStatus("Creating walls...", 70);
                await createWalls(walls, doors, windows, width, height);
                
                // 4. Set up controls
                setupControls();
                updateStatus("Finalizing...", 90);
                
                // 5. Start animation
                animate();
                updateStatus("Ready!", 100);
                
                setTimeout(() => {
                    document.getElementById('loading').style.opacity = '0';
                    setTimeout(() => {
                        document.getElementById('loading').style.display = 'none';
                    }, 500);
                }, 1000);
                
            } catch (err) {
                showError(`Model loading failed: ${err.message}`);
            }
        }

        // ========================
        // HELPER FUNCTIONS
        // ========================
        function loadImage(src) {
            return new Promise((resolve, reject) => {
                const img = new Image();
                img.onload = () => resolve(img);
                img.onerror = () => reject(new Error(`Failed to load image: ${src}`));
                img.src = src;
            });
        }

       function processImage(img) {
    return new Promise((resolve) => {
        setTimeout(() => {
            try {
                const canvas = document.createElement('canvas');
                canvas.width = img.width;
                canvas.height = img.height;
                const ctx = canvas.getContext('2d');
                ctx.drawImage(img, 0, 0);
                
                // Get all wall pixels first
                const wallPixels = [];
                const step = 1; // Check every pixel for better wall detection
                
                for (let y = 0; y < canvas.height; y += step) {
                    for (let x = 0; x < canvas.width; x += step) {
                        const pixel = ctx.getImageData(x, y, 1, 1).data;
                        if (pixel[0] < 50 && pixel[1] < 50 && pixel[2] < 50) {
                            wallPixels.push({x, y});
                        }
                    }
                }
                
                // Group connected pixels into walls
                const walls = groupConnectedPixels(wallPixels, canvas.width, canvas.height);
                const doors = []; // You'll need to implement similar grouping for doors
                const windows = []; // And windows
                
                resolve({ 
                    walls, 
                    doors, 
                    windows,
                    width: canvas.width,
                    height: canvas.height
                });
                
            } catch (err) {
                showError(`Image processing error: ${err.message}`);
                resolve({ walls: [], doors: [], windows: [], width: 0, height: 0 });
            }
        }, 0);
    });
}

function groupConnectedPixels(pixels, imgWidth, imgHeight) {
    // This is a simplified version - you might want to implement a more robust
    // flood fill or connected components algorithm for better results
    
    const groups = [];
    const visited = new Set();
    const grid = new Array(imgWidth * imgHeight).fill(0);
    
    // Mark wall pixels
    pixels.forEach(p => {
        grid[p.y * imgWidth + p.x] = 1;
    });
    
    // Find horizontal wall segments
    for (let y = 0; y < imgHeight; y++) {
        let startX = -1;
        for (let x = 0; x < imgWidth; x++) {
            if (grid[y * imgWidth + x] === 1) {
                if (startX === -1) startX = x;
            } else {
                if (startX !== -1 && x - startX > 2) { // Minimum wall length
                    groups.push({
                        x1: startX,
                        x2: x-1,
                        y1: y,
                        y2: y,
                        horizontal: true
                    });
                }
                startX = -1;
            }
        }
    }
    
    // Find vertical wall segments
    for (let x = 0; x < imgWidth; x++) {
        let startY = -1;
        for (let y = 0; y < imgHeight; y++) {
            if (grid[y * imgWidth + x] === 1) {
                if (startY === -1) startY = y;
            } else {
                if (startY !== -1 && y - startY > 2) { // Minimum wall length
                    groups.push({
                        x1: x,
                        x2: x,
                        y1: startY,
                        y2: y-1,
                        horizontal: false
                    });
                }
                startY = -1;
            }
        }
    }
    
    return groups;
}

function createWalls(walls, doors, windows, imgWidth, imgHeight) {
    return new Promise((resolve) => {
        try {
            const wallMaterial = new THREE.MeshStandardMaterial({ 
                color: 0xf5deb3, 
                roughness: 0.7 
            });
            
            const wallsGroup = new THREE.Group();
            const scale = 0.1;
            const wallHeight = 3;
            const wallThickness = 0.2;
            
            walls.forEach(wall => {
                let width, depth;
                let centerX, centerZ;
                
                if (wall.horizontal) {
                    width = (wall.x2 - wall.x1 + 1) * scale;
                    depth = wallThickness;
                    centerX = ((wall.x1 + wall.x2) / 2 - imgWidth/2) * scale;
                    centerZ = (wall.y1 - imgHeight/2) * scale;
                } else {
                    width = wallThickness;
                    depth = (wall.y2 - wall.y1 + 1) * scale;
                    centerX = (wall.x1 - imgWidth/2) * scale;
                    centerZ = ((wall.y1 + wall.y2) / 2 - imgHeight/2) * scale;
                }
                
                const geometry = new THREE.BoxGeometry(width, wallHeight, depth);
                const mesh = new THREE.Mesh(geometry, wallMaterial);
                mesh.position.set(centerX, wallHeight/2, centerZ);
                wallsGroup.add(mesh);
            });
            
            scene.add(wallsGroup);
            console.log('Solid walls created');
            resolve();
            
        } catch (err) {
            showError(`Wall creation failed: ${err.message}`);
            resolve();
        }
    });
}

        function setupControls() {
            try {
                fpControls = new THREE.PointerLockControls(fpCamera, document.body);
                orbitControls = new THREE.OrbitControls(topDownCamera, topDownRenderer.domElement);
                orbitControls.enableRotate = false;
                
                document.addEventListener('click', (e) => {
                    if (e.target.id !== 'topDownView') {
                        fpControls.lock();
                    }
                });
                
                document.addEventListener('keydown', (e) => keys[e.code] = true);
                document.addEventListener('keyup', (e) => keys[e.code] = false);
                
            } catch (err) {
                showError(`Controls setup failed: ${err.message}`);
            }
        }

        // ========================
        // ANIMATION LOOP
        // ========================
        function animate() {
            requestAnimationFrame(animate);
            
            // Movement controls
            if (fpControls && fpControls.isLocked) {
                if (keys['KeyW']) fpControls.moveForward(moveSpeed);
                if (keys['KeyS']) fpControls.moveForward(-moveSpeed);
                if (keys['KeyA']) fpControls.moveRight(-moveSpeed);
                if (keys['KeyD']) fpControls.moveRight(moveSpeed);
            }
            
            if (orbitControls) orbitControls.update();
            
            // Render both views
            firstPersonRenderer.render(scene, fpCamera);
            topDownRenderer.render(scene, topDownCamera);
        }

        // ========================
        // WINDOW RESIZE HANDLER
        // ========================
        window.addEventListener('resize', () => {
            if (fpCamera && firstPersonRenderer) {
                fpCamera.aspect = window.innerWidth / window.innerHeight;
                fpCamera.updateProjectionMatrix();
                firstPersonRenderer.setSize(window.innerWidth, window.innerHeight);
            }
        });

        // ========================
        // START APPLICATION
        // ========================
        loadModel();
    </script>
</body>
</html>